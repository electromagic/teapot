#!/usr/bin/env ruby

# Copyright, 2012, by Samuel G. D. Williams. <http://www.codeotaku.com>
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

require 'teapot/command'
require 'time'

# FLexible Option Parser
module Flop
	class Flags
		def initialize(text)
			@text = text
			
			@ordered = text.split(/\s+\|\s+/).map{|part| Flag.new(part)}
		end
		
		def to_s
			'[' + @ordered.join(' | ') + ']'
		end
		
		def parse(input)
			@ordered.each do |flag|
				if result = flag.parse(input)
					return result
				end
			end
			
			return nil
		end
	end
	
	class Flag
		def initialize(text)
			@text = text
			
			if text =~ /(.*?)\s(\<.*?\>)/
				@prefix = $1
				@value = $2
			else
				@prefix = @text
			end
		end
		
		attr :text
		attr :prefix
		attr :value
		
		def to_s
			@text
		end
		
		def parse(input)
			if @prefix == input.first
				if @value
					input.shift(2)
				else
					input.shift(1)
				end
			end
		end
	end
	
	class Option
		def initialize(flags, description, **options)
			@flags = Flags.new(flags)
			@description = description
			
			@type = options[:type]
			@key = options[:key]
			@default = options[:default]
		end
		
		attr :name
		attr :description
		attr :type
		
		attr :key
		
		def parse(input)
			@flags.parse(input)
		end
		
		def to_a
			[@flags, @description]
		end
	end
	
	class Nested
		def initialize(name, commands, key: :command)
			@name = name
			@commands = commands
			@key = key
		end
		
		attr :key
		
		def to_a
			[@name, "One of #{@commands.keys.join(', ')}"]
		end
		
		def parse(input)
			if command = @commands[input.first]
				input.shift
				
				command.new(input)
			end
		end
	end
	
	class Consumes
		def initialize(key, type: String)
			@key = key
			@type = type
		end
		
		attr :key
		
		def parse(input)
			if @type == Array
				return input.to_a
			else
				input.shift
			end
		end
	end
	
	class Split
		def initialize(key, marker: '--')
			@key = key
			@marker = marker
		end
		
		attr :key
		
		def parse(input)
			if offset = input.index(@marker)
				input.pop(input.size - offset).tap(&:shift)
			end
		end
	end
	
	class Table
		def initialize
			@rows = []
		end
		
		attr :rows
		
		def << row
			@rows << row
		end
		
		def parse(input)
			while input.any?
				size = input.size
				
				@rows.each do |row|
					if result = row.parse(input)
						yield row.key, result, row
					end
				end
				
				raise ArgumentError.new("Could not parse #{input.inspect}") if input.size == size
			end
		end
		
		def usage
			items = Array.new
			
			@rows.each do |row|
				items << row.to_a[0]
			end
			
			items.join(' ')
		end
	end
	
	class Command
		def initialize(input)
			self.class.table.parse(input) do |key, value|
				self.send("#{key}=", value)
			end
		end
		
		def [] key
			@attributes[key]
		end
		
		class << self
			attr_accessor :description
		end
		
		def self.table
			@table ||= Table.new
		end
		
		def self.append(row)
			attr_accessor(row.key) if row.respond_to?(:key)
			
			self.table << row
		end
		
		def self.option(*args, **options)
			append Option.new(*args, **options)
		end
		
		def self.nested(*args, **options)
			append Nested.new(*args, **options)
		end
		
		def self.consumes(*args, **options)
			append Consumes.new(*args, **options)
		end
		
		def self.split(*args, **options)
			append Split.new(*args, **options)
		end
		
		def self.usage(name)
			puts "#{name} #{@table.usage}"
			@table.rows.each do |row|
				puts "\t" + row.to_a.join("\t")
				
				if command.is_a?(Nested)
					command.usage
				end
			end
		end
	end
end

module Options
	class Create < Flop::Command
		self.description = "Create a new teapot package using the specified repository."
		
		consumes :project_name
		consumes :repository
		consumes :packages, type: Array
	end

	class Generate < Flop::Command
		self.description = "Run a generator to create files in your project."
		
		option '-f | --force', "Force the generator to run even if the current work-tree is dirty.", key: :force
		
		consumes :arguments, type: Array
	end

	class Fetch < Flop::Command
		self.description = "Fetch remote packages according to the specified configuration."
		
		option '--update', "Update dependencies to the latest versions.", key: :update
		option '--no-recursion', "Don't recursively fetch dependencies.", key: :recursion
	end

	class List < Flop::Command
		self.description = "List provisions and dependencies of the specified package."
		
		consumes :packages, type: Array
	end

	class Build < Flop::Command
		self.description = "Build the specified target."
		
		option '-l <limit>', "Limit build the given number of concurrent processes.", key: :limit
		option '--only', "Only compile direct dependencies.", key: :only
		option '--continuous', "Run the build graph continually (experimental).", key: :continuous
		
		split :argv, marker: '--'
		consumes :targets, type: Array
	end

	class Clean < Flop::Command
		self.description = "Delete everything in the teapot directory."
	end

	class Help < Flop::Command
		self.description = "Show detailed information about a specified command."
	end

	class Teapot < Flop::Command
		self.description = "A decentralised package manager and build tool."
		#version "1.0.0"
		
		option '-c', "Specify a specific build configuration", key: :configuration
		option '-i <path>', "Work in the given root directory", key: :root
		option '--verbose | --quiet', "Verbose output for debugging.", key: :logging
		
		nested '<command>',
			'create' => Create,
			'generate' => Generate,
			'fetch' => Fetch,
			'list' => List,
			'build' => Build,
			'clean' => Clean
	end
end

def track_time
	start_time = Time.now
	
	yield
ensure
	end_time = Time.now
	elapsed_time = end_time - start_time
	
	$stdout.flush
	$stderr.puts Rainbow("Elapsed Time: %0.3fs" % elapsed_time).magenta
end

options = Options::Teapot.new(ARGV)

puts options.inspect

track_time do
	begin
		Teapot::Command.invoke(options)
	rescue Teapot::IncompatibleTeapotError => error
		$stderr.puts error.message.color(:red)
		$stderr.puts "Supported minimum version #{Teapot::MINIMUM_LOADER_VERSION.dump} to #{Teapot::LOADER_VERSION.dump}."
		
		exit 1
	rescue Teapot::Dependency::UnresolvedDependencyError => error
		$stderr.puts "Unresolved dependencies:"

		error.chain.unresolved.each do |(name, parent)|
			$stderr.puts "#{parent} depends on #{name.inspect}".color(:red)
		
			conflicts = error.chain.conflicts[name]
		
			if conflicts
				conflicts.each do |conflict|
					$stderr.puts " - provided by #{conflict.name}".color(:red)
				end
			end
		end
	
		$stderr.puts "Cannot continue due to unresolved dependencies!".color(:red)
		
		exit 2
	rescue StandardError => error
		$stderr.puts error.message.color(:red)
		
		# Could be nice to have some improved error reporting.
		$stderr.puts error.backtrace
		
		exit 3
	end
end
